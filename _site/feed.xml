<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.0.2">Jekyll</generator><link href="http://maintainablecode.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://maintainablecode.com/" rel="alternate" type="text/html" /><updated>2016-01-23T23:13:51+01:00</updated><id>http://maintainablecode.com/</id><title>Maintainable Code</title><subtitle>In search of</subtitle><entry><title>Interactive code reviews are a waste</title><link href="http://maintainablecode.com/interactive-code-reviews-are-a-waste/" rel="alternate" type="text/html" title="Interactive code reviews are a waste" /><published>2016-01-23T00:00:00+01:00</published><updated>2016-01-23T00:00:00+01:00</updated><id>http://maintainablecode.com/interactive-code-reviews-are-a-waste</id><content type="html" xml:base="http://maintainablecode.com/interactive-code-reviews-are-a-waste/">&lt;p&gt;Code reviews have been around at least since the late &amp;#39;70s. These days, most software development teams worth their salt do code reviews. However, not all code reviews were created equal, and one particularly prevalent type is worthless at best.&lt;/p&gt;

&lt;p&gt;The type of code review I have seen the most is what I like to call the &amp;quot;interactive&amp;quot; code review. Here, the author and the reviewer sit down together to go through the code. If they are co-located, the review will often take place at the author&amp;#39;s desk. Otherwise, it might be facilitated by video conferencing software. While this is typically a speedy process, the interactive code review process has a number of drawbacks, that I would like to highlight:&lt;/p&gt;

&lt;h4 id=&quot;the-author-tends-to-take-the-driver-39-s-seat&quot;&gt;The author tends to take the driver&amp;#39;s seat&lt;/h4&gt;

&lt;p&gt;When the reviwer and the author sit together, the author tends to take the driver&amp;#39;s seat, guiding the reviewer through the code. This often happens because the author is eager to show off his work or because he has been toiling with this task for a while and is aching to close it and move on. &lt;/p&gt;

&lt;p&gt;While the author gives his whirlwind presentation, the reviewer has to&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;understand the problem that the author is addressing.&lt;/li&gt;
&lt;li&gt;think critically about the solution.&lt;/li&gt;
&lt;li&gt;wonder if the code would actually be understandable without a guided tour.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Having to juggle all these tasks is a tall order, and the reviewer will typically end up making assumptions and easing off on the critical thinking. This, of course, greatly reduces the quality of the review. In addition, a guided tour of the code is counterproductive when the reviewer is supposed to asses whether the code is easily readable and understandable.&lt;/p&gt;

&lt;h4 id=&quot;social-pressure&quot;&gt;Social pressure&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=2819015&quot;&gt;Research carried out by Microsoft Research&lt;/a&gt; shows that the reviewer&amp;#39;s position in the social hierarchy of the team influences the quality of the code review, causing a reviewer to be less critical of code written by someone higher in the social hierarchy. This effect is likely to be exacerbated when the author and the reviewer sit together.&lt;/p&gt;

&lt;h4 id=&quot;lack-of-flexibility&quot;&gt;Lack of flexibility&lt;/h4&gt;

&lt;p&gt;To do a review together, the author and the reviewer have to agree on a free time slot for the review. This leads to interruptions and a preference for short code reviews. It also means that having multiple review iterations and having multiple reviewers becomes a real pain.&lt;/p&gt;

&lt;h4 id=&quot;introspection&quot;&gt;Introspection&lt;/h4&gt;

&lt;p&gt;It is not all bad news, however. As the author goes through the code and explains it to the reviewer, he revisits and articulates his own thought process. This may lead him to realise an error in his reasoning or a fault in his assumptions, or it may just highlight that some part of his code is not as easily understandable as he initially thought. Such experiences teaches the author about himself and his habits. As Galileo said: &amp;quot;You cannot teach a man anything; you can only help him to find it within himself.&amp;quot;&lt;/p&gt;

&lt;p&gt;Despite this, having to interrupt a colleague for a code review seems like a high price to pay to have the author go over his own thought process. After all, he might as well have have been talking to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Rubber_duck_debugging&quot;&gt;rubber duck&lt;/a&gt; or a &lt;a href=&quot;http://www.sjbaker.org/humor/cardboard_dog.html&quot;&gt;cardboard cutout dog&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;code-reviews-done-right&quot;&gt;Code reviews done right&lt;/h2&gt;

&lt;p&gt;So, how do we do code reviews more efficiently? Well, what would you do if the matter to review was a quote for a client, or a piece of prose, and you were the author? You would let the reviewer read the prose in silence and in his own time. After all, what you are after is his assesment of your work. Is it a pleasant read? Is it easily understandable? Is it correct?&lt;/p&gt;

&lt;p&gt;This leads us to the conclusion that efficient code reviews should&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;be left solely to the reviewer.&lt;/li&gt;
&lt;li&gt;be done asynchronously.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Allowing the reviewer to do the review in his own time means that he can pick up the work when it suits him, and he can take the time he needs for a thorough review. It also means that having multiple reviewers becomes much more feasible. &lt;/p&gt;

&lt;p&gt;The experience of a reviewer doing a review in isolation is comparable to that of a developer, who later has to pick up the code to make changes. Thus, this is a good test for whether the code is actually maintainable. Moreover, since the reviewer will have to communicate with the author in writing, any questions raised or decisions reached during the review will be documented for future reference.&lt;/p&gt;

&lt;p&gt;Most version control services provide some mechanism for reviewing code in this manner. Bitbucket and Github both provide excellent tools for reviewing pull requests in this manner. Even if you are not using one of these services, you still have &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_tools_for_code_review&quot;&gt;lots of options&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Avoid the interactive code reviews. They are, at best, a waste of time. To be effective, code reviews must be carried out on the reviewer&amp;#39;s terms.&lt;/p&gt;</content><summary>Code reviews have been around at least since the late &amp;#39;70s. These days, most software development teams worth their salt do code reviews. However, not all code reviews were created equal, and one particularly prevalent type is worthless at best.</summary></entry><entry><title>Why Maintainable Code?</title><link href="http://maintainablecode.com/Why-Maintainable-Code/" rel="alternate" type="text/html" title="Why Maintainable Code?" /><published>2016-01-22T00:00:00+01:00</published><updated>2016-01-22T00:00:00+01:00</updated><id>http://maintainablecode.com/Why-Maintainable-Code</id><content type="html" xml:base="http://maintainablecode.com/Why-Maintainable-Code/">&lt;p&gt;The software development industry, being a part of the general tech industry, is obsessed with new technological advances that promise to make our work simpler and us more productive. Every day, new tools, frameworks and libraries are released, marketed, hyped, and blogged about. Most of them promise to increase productivity and to reduce complexity. Most deliver as promised in the short run, but none will save us in the long run.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;quot;We have to keep it crisp, disentangled, and simple if we refuse to be crushed by the complexities of our own making&amp;quot; - Dijkstra&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;With the current shortage of programmers in the Western World, pretty much anyone can get a job banging out a couple of thousand lines of incoherent, kafkaesque gibberish, and then move on to the next task. If they keep up with the new, shiny tools in their particular area of expertise, they may even come to be considered good at what they do. And since the demand for programmers is unlikely to be satisfied anytime soon, they can even make a living from this for a while. I should know - I did it for years.&lt;/p&gt;

&lt;h4 id=&quot;maintainable-code&quot;&gt;Maintainable code&lt;/h4&gt;

&lt;p&gt;As Dijkstra points out, however, if you have made a mess, it will eventually catch up with you. No tool, library, framework, or language will save you from the burden of complexity in the long run. And, after all, in the long run, it is the long run that is really interesting.&lt;/p&gt;

&lt;p&gt;Hence, this blog is about not making a mess. It is about surviving in the long run, co-existing with, maintaining, and evolving the code you once wrote. Succeeding, more than anything, requires discipline, prudence and humility. It requires putting in an effort to write clear, concise, readable code. All the time. Every day. This is no easy feat.&lt;/p&gt;

&lt;p&gt;Hence, Maintainable Code.&lt;/p&gt;</content><summary>The software development industry, being a part of the general tech industry, is obsessed with new technological advances that promise to make our work simpler and us more productive. Every day, new tools, frameworks and libraries are released, marketed, hyped, and blogged about. Most of them promise to increase productivity and to reduce complexity. Most deliver as promised in the short run, but none will save us in the long run.</summary></entry></feed>
