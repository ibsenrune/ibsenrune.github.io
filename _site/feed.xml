<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.0.2">Jekyll</generator><link href="http://maintainablecode.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://maintainablecode.com/" rel="alternate" type="text/html" /><updated>2016-04-21T16:33:29+02:00</updated><id>http://maintainablecode.com/</id><title>Maintainable Code</title><subtitle>In search of</subtitle><entry><title>Rallying the team</title><link href="http://maintainablecode.com/values-principles-and-practices-of-maintainable-code/" rel="alternate" type="text/html" title="Rallying the team" /><published>2016-04-21T16:33:29+02:00</published><updated>2016-04-21T16:33:29+02:00</updated><id>http://maintainablecode.com/values-principles-and-practices-of-maintainable-code</id><content type="html" xml:base="http://maintainablecode.com/values-principles-and-practices-of-maintainable-code/">&lt;p&gt;&lt;em&gt;How do you make a team produce maintainable code? Let values drive your  principles and practices&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Consistently producing maintainable code is hard. Many factors work against you:
- time pressure
- eager and bold new developers
- plain laziness&lt;/p&gt;

&lt;p&gt;Time pressure and plain laziness will encourage developers to make short cuts. New developers may not fully understand the application architecture and will produce code and dependencies that violate that architecture. It takes just a moment of inattention for code rot to creep in, and once that is in, the Broken Windows Syndrome makes it likely to spread.&lt;/p&gt;

&lt;p&gt;So, how do you make the team pay attention to maintainable code, all the time?&lt;/p&gt;

&lt;p&gt;You need 
First off, you define &lt;em&gt;maintainable code&lt;/em&gt; as a core value, and you articulate this to the team and to management. Next, you derive principles from this value. Eventually, you &lt;/p&gt;

&lt;p&gt;Writing maintainable code is a continuous effort. Time pressure, eager new developers and plain laziness are all forces that tear at the code.&lt;/p&gt;

&lt;p&gt;NOTE: find motivating example in literature or history - when has somebody let values define their principles and practices and lead their peers through that?&lt;/p&gt;

&lt;p&gt;Articulating maintainability as a value means that you can derive your principles and practices from this.
Values can and should be discussed and defined in cooperation with the business.&lt;/p&gt;

&lt;p&gt;I recently drew up the Developer&amp;#39;s Creed for the development team at a client. It went something like this:&lt;/p&gt;

&lt;h3 id=&quot;values&quot;&gt;Values&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;We value an uninterrupted and bug free service.&lt;/li&gt;
&lt;li&gt;We value long term productivity.&lt;/li&gt;
&lt;li&gt;We value maintainability.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;principles&quot;&gt;Principles&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;We err on the side of caution.&lt;/li&gt;
&lt;li&gt;We strive for backwards compatibility.&lt;/li&gt;
&lt;li&gt;Less code is better, because code is a liability, not an asset.&lt;/li&gt;
&lt;li&gt;We strive for composable, side-effect free units of functionality.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;practices&quot;&gt;Practices&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;TDD, unit test pretty much everything.&lt;/li&gt;
&lt;li&gt;All changes are peer reviewed.&lt;/li&gt;
&lt;li&gt;Deployed services are heavily monitored.&lt;/li&gt;
&lt;li&gt;We do continuous delivery.&lt;/li&gt;
&lt;/ul&gt;</content><summary>How do you make a team produce maintainable code? Let values drive your  principles and practices.</summary></entry><entry><title>Value objects reduce cognitive load</title><link href="http://maintainablecode.com/value-objects-reduce-cognitive-load/" rel="alternate" type="text/html" title="Value objects reduce cognitive load" /><published>2016-04-21T16:33:29+02:00</published><updated>2016-04-21T16:33:29+02:00</updated><id>http://maintainablecode.com/value-objects-reduce-cognitive-load</id><content type="html" xml:base="http://maintainablecode.com/value-objects-reduce-cognitive-load/">&lt;p&gt;I read an article once about how much information is inerrable from the type of a function??&lt;/p&gt;</content><category term="out" /><category term="of" /><category term="the" /><category term="tar" /><category term="pit" /><summary>I read an article once about how much information is inerrable from the type of a function??</summary></entry><entry><title>On the result of code reviews</title><link href="http://maintainablecode.com/on-the-result-of-code-reviews/" rel="alternate" type="text/html" title="On the result of code reviews" /><published>2016-04-21T16:33:29+02:00</published><updated>2016-04-21T16:33:29+02:00</updated><id>http://maintainablecode.com/on-the-result-of-code-reviews</id><content type="html" xml:base="http://maintainablecode.com/on-the-result-of-code-reviews/">&lt;p&gt;&lt;em&gt;Teams evaluating the pros and cons of code reviews often draw wrong conclusions. This is because the main benefit of code reviews is not what they think.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Code reviews have a long history in our industry. I think this stems from the old mantra &amp;quot;the cheapest way to remove bugs is to not put them in in the first place.&amp;quot; One way of removing bugs before they are put into  them into our software is to do code reviews. &lt;/p&gt;

&lt;p&gt;So, you would think that code reviews were an established part of our craft and that everybody did them. You would think that code reviews were taught at universities. Yet, they are not. Code reviews are not taught at universities, and many teams do not do code reviews.&lt;/p&gt;

&lt;p&gt;This is because the number of bugs found by code reviews does not retfærdiggøre the substantial effort that goes into doing proper code reviews. Teams may try out code reviews for a while, but when they pause to evaluate and think about the number of bugs found in, they are likely conclude that code reviews are too costly. And they are probably right.&lt;/p&gt;

&lt;p&gt;Doing code reviews to remove bugs is a fallacy! Research by Microsoft shows, that only 15% of review comments pertain to possible bugs in the code.&lt;/p&gt;

&lt;p&gt;However, my experience shows that this is not the case at all. 
They used to be called formal inspections and consist of a large number of people sitting in a meeting reviewing code. These days, code reviews are typically more light weight. &lt;/p&gt;

&lt;p&gt;Outline:
The purpose of the code review is not what you think. Most programmers think that code reviews are performed to catch bugs (Back this up with Microsoft Research Article.). Instead, the real benefit of code reviews is maintainable code. This view of things is supported by the fact (find reference) that 
the cheapest way to remove bugs is not to put them in  in the first place.
Now, this means that when teams evaluate the benefits of code reviews versus the drawbacks (a proper code review takes time), they are inclined to count the number of bugs found in code reviews, compare that to the time spent in code reviews and on that basis conclude that code reviews are not worth the effort.&lt;/p&gt;

&lt;p&gt;Code reviews do not find bugs. Thus, they are not worth teaching in universities, where students do not maintain code over extended periods of time.&lt;/p&gt;

&lt;p&gt;Sell code reviews!&lt;/p&gt;</content><summary>Teams evaluating the pros and cons of code reviews often draw wrong conclusions. This is because the main benefit of code reviews is not what they think.</summary></entry><entry><title>It&amp;#39;s the little things</title><link href="http://maintainablecode.com/it-is-all-the-little-things/" rel="alternate" type="text/html" title="It&#39;s the little things" /><published>2016-04-21T16:33:29+02:00</published><updated>2016-04-21T16:33:29+02:00</updated><id>http://maintainablecode.com/it-is-all-the-little-things</id><content type="html" xml:base="http://maintainablecode.com/it-is-all-the-little-things/">&lt;p&gt;&lt;em&gt;Low level code quality matters way more than your architectural style. When your code base is turning into an alienated stranger, an unmaintainable pulp, and you are itching to rewrite the whole thing, stop. Salvation may be much closer and less risky than you think&lt;/em&gt;. &lt;/p&gt;

&lt;p&gt;Have you ever had the feeling that, after toiling with a code base for 6-12 months, the code base has not turned into the beautiful thing you set out to build? You had the best intentions and swore that &lt;em&gt;this time&lt;/em&gt;, it was going to be different. Still, as you look at the code base now, it has scars and warts. You are no longer confident when making changes - heck, maybe you don&amp;#39;t even really trust the code base. And every time you touch a piece of it, you think &amp;quot;this thing really needs to be refactored&amp;quot;.&lt;/p&gt;

&lt;p&gt;So, you take the plunge. You start rewriting the whole thing. You put in long hours. You are spewing code, and you are one with the code. You change the architecture to the latest fad. You upgrade all your tools, frameworks, and libraries. For a while, you love the code again, and it loves you. &lt;/p&gt;

&lt;p&gt;You know what is coming, don&amp;#39;t you? &lt;/p&gt;

&lt;p&gt;After a while, you start to have doubts. You have had to make a few compromises. The code is becoming harder to understand than you had anticipated. Maybe the architectural style you chose doesn&amp;#39;t fit your application as well as you had been lead to believe? Changes are taking longer and longer because the code is becoming an entangled, brittle mess. Again. You are back where you started.&lt;/p&gt;

&lt;p&gt;So, what happened? How could it have come to this?&lt;/p&gt;

&lt;p&gt;You changed the tools, you changed the frameworks, and you changed the libraries. You changed the architecture. You probably introduced more automated tests. Maybe you even changed the programming language. What is left? You.&lt;/p&gt;

&lt;p&gt;What you probably did not change is the way you write code. You did not change the level of attention you pay to detail. You did not become more critical of your own code.&lt;/p&gt;

&lt;p&gt;Yet, this is exactly what is needed. &lt;/p&gt;

&lt;p&gt;Unless your initial choice of programming language was &lt;a href=&quot;https://en.wikipedia.org/wiki/Brainfuck&quot;&gt;brainfuck&lt;/a&gt;, chances are that others have had great success with this language. Your pick of tools, frameworks and libraries were probably fine. Your architectural style is overrated. You can do a &lt;a href=&quot;https://en.wikipedia.org/wiki/Multilayered_architecture&quot;&gt;Multilayered Architecture&lt;/a&gt;, a &lt;a href=&quot;https://vimeo.com/131633177&quot;&gt;Sliced Architecture&lt;/a&gt;, a &lt;a href=&quot;http://alistair.cockburn.us/Hexagonal+architecture&quot;&gt;Hexagonal Architecture&lt;/a&gt;, or an &lt;a href=&quot;http://jeffreypalermo.com/blog/the-onion-architecture-part-1/&quot;&gt;Onion Architecture&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It all doesn&amp;#39;t matter one iota if you do not pay attention to the individual characters on your screen that make up your code. You must care for your code blocks, just like an author cares for and nurtures the sentences he produces.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;quot;We have to keep it crisp, disentangled, and simple if we refuse to be crushed by the complexities of our own making&amp;quot; - Dijkstra&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Does your code suffer from any of these code smells:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;objects are mutable for no good reason.&lt;/li&gt;
&lt;li&gt;the most prevalent data types in use are integers and strings (&lt;a href=&quot;http://c2.com/cgi/wiki?PrimitiveObsession&quot;&gt;primitive obsession&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;objects that represent a value (a point, an address, a score) have reference equality semantics.&lt;/li&gt;
&lt;li&gt;some methods consider &lt;code&gt;null&lt;/code&gt; a valid argument while others do not.&lt;/li&gt;
&lt;li&gt;naming is sloppy and inconsistent.&lt;/li&gt;
&lt;li&gt;formatting is sloppy and inconsistent.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The effect of each of these code smells may seem benign. Heck, what does it matter if that &lt;code&gt;Address&lt;/code&gt; type is just a bunch of public getters and setters? What does it matter if we use &lt;code&gt;string&lt;/code&gt; to represent an order reference number? That code block is not properly indented. So what?&lt;/p&gt;

&lt;p&gt;Well, every time you introduce (or neglect to remove) one of these code smells, you are putting more &lt;a href=&quot;https://en.wikipedia.org/wiki/Cognitive_load&quot;&gt;cognitive load&lt;/a&gt; on the Code Reader. The compounding effect of all these little things can be enormous. Even if &lt;em&gt;you&lt;/em&gt; know that the code is working perfectly, the &lt;em&gt;Code Reader&lt;/em&gt; (who might, after all, be you in a couple of weeks) will be spending precious mental resources wondering whether some distant part of the program could possibly change the value of that &lt;code&gt;Address&lt;/code&gt;, or whether that order reference number could, in some obscure scenario, be &lt;code&gt;null&lt;/code&gt; and if that is a valid value.&lt;/p&gt;

&lt;p&gt;By fixing these code smells, you free up mental resources. You will be able to keep larger portions of the code in your mind at one time. As a consequence, you will start having more confidence in the code and implementing changes and solving problems will require much less effort.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Before you decide that your code base needs fundamental rewriting and that your tools and architecture need to be killed off, take a long, hard look at the low level quality of your code. You may very well be able to get back to a crisp, disentangled, and simple code base just by rectifying the quality of your code at the very low level. There is no demand to pause development. Rectifying the code from the ground up can be done in small, incremental steps while stile fixing bugs and delivering new features. In fact, improving your code base from the ground up should be part of your daily routine.&lt;/p&gt;</content><category term="out" /><category term="of" /><category term="the" /><category term="tar" /><category term="pit" /><summary>Low level code quality matters way more than your architectural style. When your code base is turning into an alienated stranger, an unmaintainable pulp, and you are itching to rewrite the whole thing, stop. Salvation may be much closer and less risky than you think.</summary></entry><entry><title>Adopting F# in the enterprise</title><link href="http://maintainablecode.com/adopting-fsharp-in-an-enterprise/" rel="alternate" type="text/html" title="Adopting F# in the enterprise" /><published>2016-04-21T16:33:29+02:00</published><updated>2016-04-21T16:33:29+02:00</updated><id>http://maintainablecode.com/adopting-fsharp-in-an-enterprise</id><content type="html" xml:base="http://maintainablecode.com/adopting-fsharp-in-an-enterprise/">&lt;p&gt;Challenges:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Testing functional code is different

&lt;ul&gt;
&lt;li&gt;Mocking&lt;/li&gt;
&lt;li&gt;Composition&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Tooling can be a challenge&lt;/li&gt;
&lt;li&gt;Developers need to be eager to learn&lt;/li&gt;
&lt;li&gt;Developers should appreciate the strengths of F#: immutability, composability, monads etc. If developers are not mature enough to appreciate these things, they may resist.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;May want to see this as well: &lt;a href=&quot;https://skillsmatter.com/skillscasts/7430-enterprise-f-sharp&quot;&gt;https://skillsmatter.com/skillscasts/7430-enterprise-f-sharp&lt;/a&gt; .&lt;/p&gt;</content><category term="functional" /><summary>Challenges:</summary></entry><entry><title>Interactive code reviews are a waste</title><link href="http://maintainablecode.com/interactive-code-reviews-are-a-waste/" rel="alternate" type="text/html" title="Interactive code reviews are a waste" /><published>2016-01-23T00:00:00+01:00</published><updated>2016-01-23T00:00:00+01:00</updated><id>http://maintainablecode.com/interactive-code-reviews-are-a-waste</id><content type="html" xml:base="http://maintainablecode.com/interactive-code-reviews-are-a-waste/">&lt;p&gt;Code reviews have been around at least since the late &amp;#39;70s. These days, most software development teams worth their salt do code reviews. However, not all code reviews were created equal, and one particularly prevalent type is worthless at best.&lt;/p&gt;

&lt;p&gt;The type of code review I have seen the most is what I like to call the &amp;quot;interactive&amp;quot; code review. Here, the author and the reviewer sit down together to go through the code. If they are co-located, the review will often take place at the author&amp;#39;s desk. Otherwise, it might be facilitated by video conferencing software. While this is typically a speedy process, the interactive code review process has a number of drawbacks, that I would like to highlight:&lt;/p&gt;

&lt;h4 id=&quot;the-author-tends-to-take-the-driver-39-s-seat&quot;&gt;The author tends to take the driver&amp;#39;s seat&lt;/h4&gt;

&lt;p&gt;When the reviwer and the author sit together, the author tends to take the driver&amp;#39;s seat, guiding the reviewer through the code. This often happens because the author is eager to show off his work or because he has been toiling with this task for a while and is aching to close it and move on. &lt;/p&gt;

&lt;p&gt;While the author gives his whirlwind presentation, the reviewer has to&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;understand the problem that the author is addressing.&lt;/li&gt;
&lt;li&gt;think critically about the solution.&lt;/li&gt;
&lt;li&gt;wonder if the code would actually be understandable without a guided tour.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Having to juggle all these tasks is a tall order, and the reviewer will typically end up making assumptions and easing off on the critical thinking. This, of course, greatly reduces the quality of the review. In addition, a guided tour of the code is counterproductive when the reviewer is supposed to asses whether the code is easily readable and understandable.&lt;/p&gt;

&lt;h4 id=&quot;social-pressure&quot;&gt;Social pressure&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=2819015&quot;&gt;Research carried out by Microsoft Research&lt;/a&gt; shows that the reviewer&amp;#39;s position in the social hierarchy of the team influences the quality of the code review, causing a reviewer to be less critical of code written by someone higher in the social hierarchy. This effect is likely to be exacerbated when the author and the reviewer sit together.&lt;/p&gt;

&lt;h4 id=&quot;lack-of-flexibility&quot;&gt;Lack of flexibility&lt;/h4&gt;

&lt;p&gt;To do a review together, the author and the reviewer have to agree on a free time slot for the review. This leads to interruptions and a preference for short code reviews. It also means that having multiple review iterations and having multiple reviewers becomes a real pain.&lt;/p&gt;

&lt;h4 id=&quot;introspection&quot;&gt;Introspection&lt;/h4&gt;

&lt;p&gt;It is not all bad news, however. As the author goes through the code and explains it to the reviewer, he revisits and articulates his own thought process. This may lead him to realise an error in his reasoning or a fault in his assumptions, or it may just highlight that some part of his code is not as easily understandable as he initially thought. Such experiences teaches the author about himself and his habits. As Galileo said: &amp;quot;You cannot teach a man anything; you can only help him to find it within himself.&amp;quot;&lt;/p&gt;

&lt;p&gt;Despite this, having to interrupt a colleague for a code review seems like a high price to pay to have the author go over his own thought process. After all, he might as well have have been talking to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Rubber_duck_debugging&quot;&gt;rubber duck&lt;/a&gt; or a &lt;a href=&quot;http://www.sjbaker.org/humor/cardboard_dog.html&quot;&gt;cardboard cutout dog&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;code-reviews-done-right&quot;&gt;Code reviews done right&lt;/h2&gt;

&lt;p&gt;So, how do we do code reviews more efficiently? Well, you can ask yourself: what would you do, if the matter to review was a quote for a client, or a piece of prose, and you were the author? I bet you would let the reviewer read the prose in silence and in his own time. After all, what you are after is his experience reading it,  his assesment of your work. Is it a pleasant read? Is it easily understandable? Is it correct?&lt;/p&gt;

&lt;p&gt;This leads us to the conclusion that efficient code reviews should&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;be left solely to the reviewer.&lt;/li&gt;
&lt;li&gt;be done asynchronously.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Allowing the reviewer to do the review in his own time means that he can pick up the work when it suits him, and he can take the time he needs for a thorough review. It also means that having multiple reviewers becomes much more feasible. &lt;/p&gt;

&lt;p&gt;The experience of a reviewer doing a review in isolation is comparable to that of a developer, who later has to pick up the code to make changes. Thus, this is a good test for whether the code is actually maintainable. Moreover, since the reviewer will have to communicate with the author in writing, any questions raised or decisions reached during the review will be documented for future reference.&lt;/p&gt;

&lt;p&gt;Most version control services provide some mechanism for reviewing code in this manner. Bitbucket and Github both provide excellent tools for reviewing pull requests in this manner. Even if you are not using one of these services, you still have &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_tools_for_code_review&quot;&gt;lots of options&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Avoid the interactive code reviews. They are, at best, a waste of time. To be effective, code reviews must be carried out on the reviewer&amp;#39;s terms.&lt;/p&gt;</content><summary>Code reviews have been around at least since the late &amp;#39;70s. These days, most software development teams worth their salt do code reviews. However, not all code reviews were created equal, and one particularly prevalent type is worthless at best.</summary></entry><entry><title>Why Maintainable Code?</title><link href="http://maintainablecode.com/Why-Maintainable-Code/" rel="alternate" type="text/html" title="Why Maintainable Code?" /><published>2016-01-22T00:00:00+01:00</published><updated>2016-01-22T00:00:00+01:00</updated><id>http://maintainablecode.com/Why-Maintainable-Code</id><content type="html" xml:base="http://maintainablecode.com/Why-Maintainable-Code/">&lt;p&gt;The software development industry, being a part of the general tech industry, is obsessed with new technological advances that promise to make our work simpler and us more productive. Every day, new tools, frameworks and libraries are released, marketed, hyped, and blogged about. Most of them promise to increase productivity and to reduce complexity. Most deliver as promised in the short run, but none will save us in the long run.&lt;/p&gt;

&lt;p&gt;With the current shortage of programmers in the Western World, pretty much anyone can get a job banging out a couple of thousand lines of incoherent, kafkaesque gibberish, and then move on to the next task. If they keep up with the new, shiny tools in their particular area of expertise, they may even come to be considered good at what they do. And since the demand for programmers is unlikely to be satisfied anytime soon, they can even make a living from this for a while. I should know - I did it for years.&lt;/p&gt;

&lt;h4 id=&quot;maintainable-code&quot;&gt;Maintainable code&lt;/h4&gt;

&lt;p&gt;However, if you have made a mess, it will eventually catch up with you. No tool, library, framework, or language will save you from the burden of complexity in the long run. And, after all, in the long run, it is the long run that is really interesting.&lt;/p&gt;

&lt;p&gt;Hence, this blog is about not making a mess. It is about surviving in the long run, co-existing with, maintaining, and evolving the code you once wrote. Succeeding, more than anything, requires discipline, prudence and humility. It requires putting in an effort to write clear, concise, readable code. All the time. Every day. This is no easy feat.&lt;/p&gt;

&lt;p&gt;Hence, Maintainable Code.&lt;/p&gt;</content><summary>The software development industry, being a part of the general tech industry, is obsessed with new technological advances that promise to make our work simpler and us more productive. Every day, new tools, frameworks and libraries are released, marketed, hyped, and blogged about. Most of them promise to increase productivity and to reduce complexity. Most deliver as promised in the short run, but none will save us in the long run.</summary></entry></feed>
